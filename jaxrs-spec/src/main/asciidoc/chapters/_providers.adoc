[[providers]]
== Providers

Providers in JAX-RS are responsible for various cross-cutting concerns
such as filtering requests, converting representations into Java
objects, mapping exceptions to responses, etc. A provider can be either
_pre-packaged_ in the JAX-RS runtime or supplied by an application. All
_application-supplied_ providers implement interfaces in the JAX-RS API
and MAY be annotated with `@Provider` for automatic discovery purposes;
the integration of pre-packaged providers into the JAX-RS runtime is
implementation dependent.

This chapter introduces some of the basic JAX-RS providers; other
providers are introduced in Chapter <<client_api>> and Chapter
<<filters_and_interceptors>>.

[[lifecycle_and_environment]]
=== Lifecycle and Environment

By default a single instance of each provider class is instantiated for
each JAX-RS application. First the constructor (see
<<provider_class_constructor>>) is called, then any requested dependencies
are injected (see Chapter <<context>>), then the appropriate provider
methods may be called multiple times (simultaneously), and finally the
object is made available for garbage collection.
<<providercontext>> describes how a provider obtains access to other
providers via dependency injection.

An implementation MAY offer other provider lifecycles, mechanisms for
specifying these are outside the scope of this specification. E.g. an
implementation based on an inversion-of-control framework may support
all of the lifecycle options provided by that framework.

[[automatic_discovery]]
==== Automatic Discovery

The annotation `@Provider` is used by a JAX-RS runtime to automatically
discover provider classes via mechanisms such as class scanning. A
JAX-RS implementation that supports automatic discovery of classes MUST
process only those classes that are annotated with `@Provider`.

[[provider_class_constructor]]
==== Constructors

Provider classes that are instantiated by the JAX-RS runtime and MUST
have a public constructor for which the JAX-RS runtime can provide all
parameter values. Note that a zero argument constructor is permissible
under this rule.

A public constructor MAY include parameters annotated with
`@Context`—Chapter <<context>> defines the parameter types permitted for
this annotation. Since providers may be created outside the scope of a
particular request, only deployment-specific properties may be available
from injected interfaces at construction time; request-specific
properties are available when a provider method is called. If more than
one public constructor can be used then an implementation MUST use the
one with the most parameters. Choosing amongst constructors with the
same number of parameters is implementation specific, implementations
SHOULD generate a warning about such ambiguity.

[[provider_priorities]]
==== Priorities

Application-supplied providers enable developers to extend and customize
the JAX-RS runtime. Therefore, an application-supplied provider MUST
always be preferred over a pre-packaged one if a single one is required.

Application-supplied providers may be annotated with `@Priority`. If two
or more providers are candidates for a certain task, the one with the
_highest_ priority is chosen: the highest priority is defined to be the
one with the _lowest_ value in this case. That is, `@Priority(1)` is
higher than `@Priority(10)`. If two or more providers are eligible and
have identical priorities, one is chosen in an implementation dependent
manner. The default priority for all application-supplied providers is
`javax.ws.rs.Priorities.USER`.

The general rule about priorities is different for filters and
interceptors since these providers are collected into chains. For more
information see Section <<priorities>>.

[[entity_providers]]
=== Entity Providers

Entity providers supply mapping services between representations and
their associated Java types. Entity providers come in two flavors:
`MessageBodyReader` and `MessageBodyWriter` described below.

[[message_body_reader]]
==== Message Body Reader

The `MessageBodyReader` interface defines the contract between the
JAX-RS runtime and components that provide mapping services from
representations to a corresponding Java type. A class wishing to provide
such a service implements the `MessageBodyReader` interface and may be
annotated with `@Provider` for automatic discovery.

The following describes the logicalfootnote:[Implementations are free to
optimize their processing provided the results are equivalent to those
that would be obtained if these steps are followed.] steps taken by a
JAX-RS implementation when mapping a message entity body to a Java
method parameter:

1.  Obtain the media type of the request. If the request does not
contain a `Content-Type` header then use `application/octet-stream`.
2.  Identify the Java type of the parameter whose value will be mapped
from the entity body. <<mapping_requests_to_java_methods>>
describes how the Java method is chosen.
3.  Select the set of `MessageBodyReader` classes that support the media
type of the request, see <<declaring_provider_capabilities>>.
4.  Iterate through the selected
`MessageBodyReader` classes and, utilizing the `isReadable` method of
each, choose a `MessageBodyReader` provider that supports the desired
Java type.
5.  If step 4 locates one or more suitable
`MessageBodyReader`’s then select the one with the highest priority as
described in <<provider_priorities>> and use its `readFrom` method
to map the entity body to the desired Java type.
6.  Otherwise, the server runtime MUST generate a
`NotSupportedException` (415 status) and no entity (to be processed as
described in <<method_exc>>) and the client runtime MUST generate
an instance of `ProcessingException`.

See <<exceptions_providers>> for more information on handling
exceptions thrown in `MessageBodyReader``.readFrom`.

[[message_body_writer]]
==== Message Body Writer

The `MessageBodyWriter` interface defines the contract between the
JAX-RS runtime and components that provide mapping services from a Java
type to a representation. A class wishing to provide such a service
implements the `MessageBodyWriter` interface and may be annotated with
`@Provider` for automatic discovery.

The following describes the logical steps taken by a
JAX-RS implementation when mapping a return value to a message entity
body:

1.  Obtain the object that will be mapped to the message entity body.
For a return type of `Response` or subclasses, the object is the value
of the `entity` property, for other return types it is the returned
object.
2.  Determine the media type of the response, see Section
[determine_response_type].
3.  Select the set of `MessageBodyWriter` providers that support (see
<<declaring_provider_capabilities>>) the object and media type of
the message entity body.
4.  Sort the selected `MessageBodyWriter` providers with a
primary key of generic type where providers whose generic type is the
nearest superclass of the object class are sorted first and a secondary
key of media type (see Section [declaring_provider_capabilities]).
5.  Iterate through the sorted
`MessageBodyWriter` providers and, utilizing the `isWriteable` method of
each, choose an `MessageBodyWriter` that supports the object that will
be mapped to the entity body.
6.  If step 5 locates one or more suitable
`MessageBodyWriter`’s that are equal with respect to the sorting in step
4, then select the one with the highest priority as described
in <<provider_priorities>> and use its `writeTo` method to map the
entity body to the desired Java type.
7.  Otherwise, the server runtime MUST generate a generate an
`InternalServerErrorException`, a subclass of
`WebApplicationException` with its status set to 500, and no entity (to
be processed as described in <<method_exc>>) and the client
runtime MUST generate a `ProcessingException`.

Experience gained in the field has resulted in the reversal of the
sorting keys in step 4 in this specification. This represents
a backward incompatible change with respect to JAX-RS 1.X.
Implementations of this specification are REQUIRED to provide a backward
compatible flag for those applications that rely on the previous
ordering. The mechanism defined to enable this flag is implementation
dependent.

See <<exceptions_providers>> for more information on handling
exceptions thrown in `MessageBodyWriter``.write`.

[[declaring_provider_capabilities]]
==== Declaring Media Type Capabilities

Message body readers and writers MAY restrict the media types they
support using the `@Consumes` and `@Produces` annotations respectively.
The absence of these annotations is equivalent to their inclusion with
media type (/*), i.e. absence implies that any media type is supported.
An implementation MUST NOT use an entity provider for a media type that
is not supported by that provider.

When choosing an entity provider an implementation sorts the available
providers according to the media types they declare support for. Sorting
of media types follows the general rule: x/y latexmath:[$<$] x/*
latexmath:[$<$] */*, i.e. a provider that explicitly lists a media types
is sorted before a provider that lists */*.

[[standard_entity_providers]]
==== Standard Entity Providers

An implementation MUST include pre-packaged `MessageBodyReader` and
`MessageBodyWriter` implementations for the following Java and media
type combinations:

`byte[]`::
  All media types (`/*`).
`java.lang.String`::
  All media types (`/*`).
`java.io.InputStream`::
  All media types (`/*`).
`java.io.Reader`::
  All media types (`/*`).
`java.io.File`::
  All media types (`/*`).
`javax.activation.DataSource`::
  All media types (`/*`).
`javax.xml.transform.Source`::
  XML types (`text/xml`, `application/xml` and media types of the form
  `application/*+xml`).
`javax.xml.bind.JAXBElement` and application-supplied JAXB classes::
  XML types (`text/xml` and `application/xml` and media types of the
  form `application/*+xml`).
`MultivaluedMap<String,String>`::
  Form content (`application/x-www-form-urlencoded`).
`StreamingOutput`::
  All media types (`/*`), `MessageBodyWriter` only.
`java.lang.Boolean`, `java.lang.Character`, `java.lang.Number`::
  Only for `text/plain`. Corresponding primitive types supported via
  boxing/unboxing conversion.

Depending on the environment, the list of standard entity providers MUST
also include those for JSON. For more information about these providers
see <<jsonp>> and <<jsonb>>.

When reading zero-length message entities all pre-packaged
`MessageBodyReader` implementations, except the JAXB one and those for
the (boxed) primitive types above, MUST create a corresponding Java
object that represents zero-length data. The pre-packaged JAXB and the
pre-packaged primitive type `MessageBodyReader` implementations MUST
throw a `NoContentException` for zero-length message entities.

When a `NoContentException` is thrown while reading a server request
entity from a `MessageBodyReader` it MUST be translated by the server
runtime into a `BadRequestException` wrapping the original
`NoContentException` and re-thrown to be processed by any registered
exception mappers.

The implementation-supplied entity provider(s) for
`javax.xml.bind.JAXBElement` and application-supplied JAXB classes MUST
use `JAXBContext` instances provided by application-supplied context
resolvers, see <<contextprovider>>. If an application does not
supply a `JAXBContext` for a particular type, the
implementation-supplied entity provider MUST use its own default context
instead.

When writing responses, implementations SHOULD respect
application-supplied character set metadata and SHOULD use UTF-8 if a
character set is not specified by the application or if the application
specifies a character set that is unsupported.

An implementation MUST support application-provided entity providers and
MUST use those in preference to its own pre-packaged providers when
either could handle the same request. More precisely, step 4
in <<message_body_reader>> and step 5 in
<<message_body_writer>> MUST prefer application-provided over pre-packaged
entity providers.

[[transfer_encoding]]
==== Transfer Encoding

Transfer encoding for inbound data is handled by a component of the
container or the JAX-RS runtime. `MessageBodyReader` providers always
operate on the decoded HTTP entity body rather than directly on the HTTP
message body.

A JAX-RS runtime or container MAY transfer encode outbound data or this
MAY be done by application code.

[[content-encoding]]
==== Content Encoding

Content encoding is the responsibility of the application.
Application-supplied entity providers MAY perform such encoding and
manipulate the HTTP headers accordingly.

[[contextprovider]]
=== Context Providers

Context providers supply context to resource classes and other
providers. A context provider class implements the `ContextResolver<T>`
interface and may be annotated with `@Provider` for automatic discovery.
E.g., an application wishing to provide a customized `JAXBContext` to
the default JAXB entity providers would supply a class implementing
`ContextResolver<JAXBContext>`.

Context providers MAY return `null` from the `getContext` method if they
do not wish to provide their context for a particular Java type. E.g. a
JAXB context provider may wish to only provide the context for certain
JAXB classes. Context providers MAY also manage multiple contexts of the
same type keyed to different Java types.

[[context_media_type]]
==== Declaring Media Type Capabilities

Context provider implementations MAY restrict the media types they
support using the `@Produces` annotation. The absence of this annotation
is equivalent to its inclusion with media type (/*), i.e. absence
implies that any media type is supported.

When choosing a context provider an implementation sorts the available
providers according to the media types they declare support for. Sorting
of media types follows the general rule: x/y latexmath:[$<$] x/*
latexmath:[$<$] */*, i.e. a provider that explicitly lists a media type
is sorted before a provider that lists */*.

[[exceptionmapper]]
=== Exception Mapping Providers

Exception mapping providers map a checked or runtime exception to an
instance of `Response`. An exception mapping provider implements the
`ExceptionMapper<T>` interface and may be annotated with `@Provider` for
automatic discovery.

When a resource class or provider method throws an exception for which
there is an exception mapping provider, the matching provider is used to
obtain a `Response` instance. The resulting `Response` is processed as
if a web resource method had returned the `Response`, see
<<resource_method_return>>. In particular, a mapped `Response` MUST be
processed using the ContainerResponse filter chain defined in
Chapter <<filters_and_interceptors>>.

When choosing an exception mapping provider to map an exception, an
implementation MUST use the provider whose generic type is the nearest
superclass of the exception. If two or more exception providers are
applicable, the one with the highest priority MUST be chosen as
described in <<provider_priorities>>.

To avoid a potentially infinite loop, a single exception mapper must be
used during the processing of a request and its corresponding response.
JAX-RS implementations MUST NOT attempt to map exceptions thrown while
processing a response previously mapped from an exception. Instead, this
exception MUST be processed as described in steps 3 and
4 in <<method_exc>>.

Note that exception mapping providers are _not_ supported as part of the
Client API.

[[exceptions_providers]]
=== Exceptions

Exception handling differs depending on whether a provider is part of
the client runtime or server runtime. This is covered in the next two
sections.

[[exceptions_providers_server]]
==== Server Runtime

When a provider method throws an exception, the JAX-RS server runtime
will attempt to map the exception to a suitable HTTP response in the
same way as described for methods and locators in <<method_exc>>.
If the exception is thrown while generating a response,
JAX-RS implementations are required to map the exception _only when_ the
response has not been committed yet.

As explained in <<exceptionmapper>>, an application can supply
exception mapping providers to customize this mapping, but these
exception mappers will be ignored during the processing of a _previously
mapped_ response to avoid entering a potentially infinite loop. For
example, suppose a method in a message body reader throws an exception
that is mapped to a response via an exception mapping provider; if the
message body writer throws an exception while trying to write the mapped
response, JAX-RS implementations will not attempt to map the exception
again.

[[exceptions_providers_client]]
==== Client Runtime

When a provider method throws an exception, the JAX-RS client runtime
will map it to an instance of `ProcessingException` if thrown while
processing a request, and to a `ResponseProcessingException` if thrown
while processing a response.

Note that the client runtime will only throw an instance of
`WebApplicationException` (or any of its subclasses) as a result of a
response from the server with status codes 3xx, 4xx or 5xx.
