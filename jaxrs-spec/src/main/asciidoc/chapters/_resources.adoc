[[resources]]
== Resources

Using JAX-RS a Web resource is implemented as a resource class and
requests are handled by resource methods. This chapter describes
resource classes and resource methods in detail.

[[resource-classes]]
=== Resource Classes

A resource class is a Java class that uses JAX-RS annotations to
implement a corresponding Web resource. Resource classes are POJOs that
have at least one method annotated with `@Path` or a request method
designator.

[[lifecycle-and-environment]]
==== Lifecycle and Environment

By default a new resource class instance is created for each request to
that resource. First the constructor (see <<resource_class_constructor>>)
is called, then any requested dependencies
are injected (see <<resource_field>>), then the appropriate method
(see <<resource_method>>) is invoked and finally the object is
made available for garbage collection.

An implementation MAY offer other resource class lifecycles, mechanisms
for specifying these are outside the scope of this specification.
E.g. an implementation based on an inversion-of-control framework may
support all of the lifecycle options provided by that framework.

[[resource_class_constructor]]
==== Constructors

Root resource classes are instantiated by the JAX-RS runtime and MUST
have a public constructor for which the JAX-RS runtime can provide all
parameter values. Note that a zero argument constructor is permissible
under this rule.

A public constructor MAY include parameters annotated with one of the
following: `@Context`, `@HeaderParam`, `@CookieParam`, `@MatrixParam`,
`@QueryParam` or `@PathParam`. However, depending on the resource class
lifecycle and concurrency, per-request information may not make sense in
a constructor. If more than one public constructor is suitable then an
implementation MUST use the one with the most parameters. Choosing
amongst suitable constructors with the same number of parameters is
implementation specific, implementations SHOULD generate a warning about
such ambiguity.

Non-root resource classes are instantiated by an application and do not
require the above-described public constructor.

[[resource_field]]
=== Fields and Bean Properties

When a resource class is instantiated, the values of fields and bean
properties annotated with one the following annotations are set
according to the semantics of the annotation:

`@MatrixParam`::
  Extracts the value of a URI matrix parameter.
`@QueryParam`::
  Extracts the value of a URI query parameter.
`@PathParam`::
  Extracts the value of a URI template parameter.
`@CookieParam`::
  Extracts the value of a cookie.
`@HeaderParam`::
  Extracts the value of a header.
`@Context`::
  Injects an instance of a supported resource, see chapters <<context>>
  and <<environment>> for more details.

Because injection occurs at object creation time, use of these
annotations (with the exception of `@Context`) on resource class fields
and bean properties is only supported for the default per-request
resource class lifecycle. An implementation SHOULD warn if resource
classes with other lifecycles use these annotations on resource class
fields or bean properties.

A JAX-RS implementation is only required to set the annotated field and
bean property values of instances created by its runtime. Objects
returned by sub-resource locators (see <<sub_resources>>) are
expected to be initialized by their creator.

Valid parameter types for each of the above annotations are listed in
the corresponding Javadoc, however in general (excluding `@Context`) the
following types are supported:

1.  Types for which a `ParamConverter` is available via
a registered `ParamConverterProvider`. See Javadoc for these classes for
more information.
2.  Primitive types.
3.  Types that have a constructor that accepts a single
`String` argument.
4.  Types that have a static method named `valueOf` or
`fromString` with a single `String` argument that return an instance of
the type. If both methods are present then `valueOf` MUST be used unless
the type is an enum in which case `fromString` MUST be usedfootnote:[Due
to limitations of the built-in `valueOf` method that is part of all Java
enumerations, a `fromString` method is often defined by the enum
writers. Consequently, the `fromString` method is preferred when
available.].
5.  `List<T>`, `Set<T>`, or `SortedSet<T>`, where `T` satisfies
1,3 or 4 above.

The `DefaultValue` annotation may be used to supply a default value for
some of the above, see the Javadoc for `DefaultValue` for usage details
and rules for generating a value in the absence of this annotation and
the requested data. The `Encoded` annotation may be used to disable
automatic URI decoding for `@MatrixParam`, `@QueryParam`, and
`@PathParam` annotated fields and properties.

A `WebApplicationException` thrown during construction of field or
property values using any of the 5 steps listed above is processed
directly as described in <<method_exc>>. Other exceptions thrown
during construction of field or property values using any of the 5 steps
listed above are treated as client errors: if the field or property is
annotated with `@MatrixParam`, `@QueryParam` or `@PathParam` then an
implementation MUST generate an instance of `NotFoundException` (404
status) that wraps the thrown exception and no entity; if the field or
property is annotated with `@HeaderParam` or `@CookieParam` then an
implementation MUST generate an instance of `BadRequestException` (400
status) that wraps the thrown exception and no entity. Exceptions MUST
be processed as described in <<method_exc>>.

[[resource_method]]
=== Resource Methods

Resource methods are methods of a resource class annotated with a
request method designator. They are used to handle requests and MUST
conform to certain restrictions described in this section.

A request method designator is a runtime annotation that is annotated
with the `@HttpMethod` annotation. JAX-RS defines a set of request
method designators for the common HTTP methods: `@GET`, `@POST`, `@PUT`,
`@DELETE`, `@PATCH`, `@HEAD` and `@OPTIONS`. Users may define their own
custom request method designators including alternate designators for
the common HTTP methods.

[[visibility]]
==== Visibility

Only `public` methods may be exposed as resource methods. An
implementation SHOULD warn users if a non-`public` method carries a
method designator or `@Path` annotation.

[[resource_method_params]]
==== Parameters

When a resource method is invoked, parameters annotated with
`@FormParam` or one of the annotations listed in Section
[resource_field] are mapped from the request according to the semantics
of the annotation. Similar to fields and bean properties:

* The `DefaultValue` annotation may be used to supply a default value
for parameters
* The `Encoded` annotation may be used to disable automatic URI decoding
of parameter values
* Exceptions thrown during construction of parameter values are treated
the same as exceptions thrown during construction of field or bean
property values, see <<resource_field>>. Exceptions thrown during
construction of `@FormParam` annotated parameter values are treated the
same as if the parameter were annotated with `@HeaderParam`.

[[entity_parameters]]
===== Entity Parameters

The value of a parameter not annotated with `@FormParam` or any of the
annotations listed in in <<resource_field>>, called the entity
parameter, is mapped from the request entity body. Conversion between an
entity body and a Java type is the responsibility of an entity provider,
see <<entity_providers>>. Resource methods MUST have at most one
entity parameter.

[[resource_method_return]]
==== Return Type

Resource methods MAY return `void`, `Response`, `GenericEntity`, or
another Java type, these return types are mapped to a response entity
body as follows:

`void`::
  Results in an empty entity body with a 204 status code.
`Response`::
  Results in an entity body mapped from the entity property of the
  `Response` with the status code specified by the status property of
  the `Response`. A `null` return value results in a 204 status code. If
  the status property of the `Response` is not set: a 200 status code is
  used for a non-`null` entity property and a 204 status code is used if
  the entity property is `null`.
`GenericEntity`::
  Results in an entity body mapped from the `Entity` property of the
  `GenericEntity`. If the return value is not `null` a 200 status code
  is used, a `null` return value results in a 204 status code.
Other::
  Results in an entity body mapped from the class of the returned
  instance or of its type parameter `T` if the return type is
  `CompletionStage<T>` (see <<completionstage>>); if the class is
  an anonymous inner class, its superclass is used instead. If the
  return value is not `null` a 200 status code is used, a `null` return
  value results in a 204 status code.

Methods that need to provide additional metadata with a response should
return an instance of `Response`, the `Response``Builder` class provides
a convenient way to create a `Response` instance using a builder
pattern.

Conversion between a Java object and an entity body is the
responsibility of an entity provider, see <<entity_providers>>.
The return type of a resource method and the type of the returned
instance are used to determine the raw type and generic type supplied to
the `isWritable` method of `MessageBodyWriter` as follows:

[id="Table 3.1"]
|==================================
|*Return Type*  |*Returned Instance*
usedfootnote:[Or `Entity` property of returned instance if return type is
`Response` or a subclass thereof.]    |*Raw Type*     |*Generic Type*
|`GenericEntity`    |`GenericEntity` or subclass    |`RawType` property
|`Type` property
|`Response` |`GenericEntity` or subclass    |`RawType` property
|`Type` property
|`Response` |`Object` or subclass   |Class of instance |Class of instance
|`Other`    |Return type or subclass    |Class of instance  |Generic type of return type
|==================================
Table 3.1: Determining raw and generic types of return values

To illustrate the above consider a method that always returns an
instance of `ArrayList<String>` either directly or wrapped in some
combination of `Response` and `GenericEntity`. The resulting raw and
generic types are shown below.

[id="Table 3.2"]
|==================================
|*Return Type*  |*Returned Instance*    |*Raw Type* |*Generic Type
|`GenericEntity`    |`GenericEntity<List<String>>`  |`ArrayList<?>` |`List<String>`
|`Response` |`GenericEntity<List<String>>`  |`ArrayList<?>` |`List<String>`
|`Response` |`ArrayList<String>`    |`ArrayList<?>` |`ArrayList<?>`
|`List<String>` |`ArrayList<String>`    |`ArrayList<?>` |`List<String>`
|==================================
Table 3.2: Example raw and generic types of return values

[[method_exc]]
==== Exceptions

A resource method, sub-resource method or sub-resource locator may throw
any checked or unchecked exception. An implementation MUST catch all
exceptions and process them in the following order:

1.  Instances of `WebApplicationException` and its subclasses MUST be
mapped to a response as follows. If the `response` property of the
exception does not contain an entity and an exception mapping provider
(see <<exceptionmapper>>) is available for
`WebApplicationException` or the corresponding subclass, an
implementation MUST use the provider to create a new
`Response` instance, otherwise the `response` property is used directly.
The resulting `Response` instance is then processed according to
<<resource_method_return>>.
2.  If an exception mapping provider (see <<exceptionmapper>>) is
available for the exception or one of its superclasses, an
implementation MUST use the provider whose generic type is the nearest
superclass of the exception to create a `Response` instance that is then
processed according to <<resource_method_return>>. If the
exception mapping provider throws an exception while creating a
`Response` then return a server error (status code 500) response to the
client.
3.  Unchecked exceptions and errors that have not been
mapped MUST be re-thrown and allowed to propagate to the underlying
container.
4.  Checked exceptions and throwables that have not been
mapped and cannot be thrown directly MUST be wrapped in a
container-specific exception that is then thrown and allowed to
propagate to the underlying container. Servlet-based implementations
MUST use `ServletException` as the wrapper. JAX-WS `Provider`-based
implementations MUST use `WebServiceException` as the wrapper.

*Note:* _Items 3 and 4 allow existing container facilities
(e.g. a Servlet filter or error pages) to be used to handle the error if
desired._

[[head_and_options]]
==== HEAD and OPTIONS

`HEAD` and `OPTIONS` requests receive additional automated support. On
receipt of a `HEAD` request an implementation MUST either:

1.  Call a method annotated with a request method designator for `HEAD`
or, if none present,
2.  Call a method annotated with a request method
designator for `GET` and discard any returned entity.

Note that option 2 may result in reduced performance where
entity creation is significant.

On receipt of an `OPTIONS` request an implementation MUST either:

1.  Call a method annotated with a request method designator for
`OPTIONS` or, if none present,
2.  Generate an automatic response using the metadata provided by the
JAX-RS annotations on the matching class and its methods.

[[uritemplates]]
=== URI Templates

A root resource class is anchored in URI space using the
`@Path` annotation. The value of the annotation is a relative URI path
template whose base URI is provided by the combination of the deployment
context and the application path (see the `@ApplicationPath`
annotation).

A URI path template is a string with zero or more embedded parameters
that, when values are substituted for all the parameters, is a valid
URI<<bib5>> path. The Javadoc for the
`@Path` annotation describes their syntax. E.g.:

[source,java,numbered]
-------------
@Path("widgets/{id}")
public class Widget {
    ...
}
-------------

In the above example the `Widget` resource class is identified by the
relative URI path `widgets/xxx` where `xxx` is the value of the `id`
parameter.

*Note:* _Because \{and } are not part of either the reserved or unreserved
productions of URI<<bib5>> they will
not appear in a valid URI._

The value of the annotation is automatically encoded, e.g. the following
two lines are equivalent:

[source,java,numbered]
-------------
@Path("widget list/{id}")
@Path("widget%20list/{id}")
-------------

Template parameters can optionally specify the regular expression used
to match their values. The default value matches any text and terminates
at the end of a path segment but other values can be used to alter this
behavior, e.g.:

[source,java,numbered]
-------------
@Path("widgets/{path:.+}")
public class Widget {
    ...
}
-------------

In the above example the `Widget` resource class will be matched for any
request whose path starts with `widgets` and contains at least one more
path segment; the value of the `path` parameter will be the request path
following `widgets`. E.g. given the request path `widgets/small/a` the
value of `path` would be `small/a`.

The value of a URI path parameter is available for injection via
`@PathParam` on a field, property or method parameter. Note that if a
URI template is used on a method, a path parameter injected in a field
or property may not be available (set to `null`). The following example
illustrates this scenario:

[source,java,numbered]
-------------
@Path("widgets")
public class WidgetsResource {
    @PathParam("id") String id;

    @GET
    public WidgetList getWidgets() {
        ...     // id is null here
    }

    @GET
    @Path("{id}")
    public Widget findWidget() {
        return new WidgetResource(id);
    }
}
-------------

[[sub_resources]]
==== Sub Resources

Methods of a resource class that are annotated with `@Path` are either
sub-resource methods or sub-resource locators. Sub-resource methods
handle a HTTP request directly whilst sub-resource locators return an
object or class that will handle a HTTP request. The presence or absence
of a request method designator (e.g. @GET) differentiates between the
two:

Present::
  Such methods, known as _sub-resource methods_, are treated like a
  normal resource method (see <<resource_method>>) except the
  method is only invoked for request URIs that match a URI template
  created by concatenating the URI template of the resource class with
  the URI template of the methodfootnote:[If the resource class URI
  template does not end with a / character then one is added during the
  concatenation.].
Absent::
  Such methods, known as _sub-resource locators_, are used to
  dynamically resolve the object that will handle the request.
  Sub-resource locators can return objects or classes; if a class is
  returned then an object is obtained by the implementation using a
  _suitable_ constructor as described in
  <<resource_class_constructor>>. In either case, the resulting object is
  used to handle the request or to further resolve the object that will
  handle the request, see <<mapping_requests_to_java_methods>> for further
  details.
  +
  When an object is returned, implementations MUST dynamically determine
  its class rather than relying on the static sub-resource locator
  return type, since the returned instance may be a subclass of the
  declared type with potentially different annotations, see
  <<annotationinheritance>> for rules on annotation inheritance.
  Sub-resource locators may have all the same parameters as a normal
  resource method (see <<resource_method>>) except that they MUST
  NOT have an entity parameter.

The following example illustrates the difference:

[source,java,numbered]
-------------
@Path("widgets")
public class WidgetsResource {
    @GET
    @Path("offers")
    public WidgetList getDiscounted() {...}

    @Path("{id}")
    public WidgetResource findWidget(@PathParam("id") String id) {
        return new WidgetResource(id);
    }
}

public class WidgetResource {
    public WidgetResource(String id) {...}

    @GET
    public Widget getDetails() {...}
}
-------------

In the above a `GET` request for the `widgets/offers` resource is
handled directly by the `getDiscounted` sub-resource method of the
resource class `WidgetsResource` whereas a `GET` request for
`widgets/xxx` is handled by the `getDetails` method of the
`WidgetResource` resource class.

*Note:* _A set of sub-resource methods annotated with the same URI template value
are functionally equivalent to a similarly annotated sub-resource
locator that returns an instance of a resource class with the same set
of resource methods._

[[declaring_method_capabilities]]
=== Declaring Media Type Capabilities

Application classes can declare the supported request and response media
types using the `@Consumes` and `@Produces` annotations respectively.
These annotations MAY be applied to a resource method, a resource class,
or to an entity provider (see <<declaring_provider_capabilities>>).
Use of these annotations on a
resource method overrides any on the resource class or on an entity
provider for a method argument or return type. In the absence of either
of these annotations, support for any media type (/*) is assumed.

The following example illustrates the use of these annotations:

[source,java,numbered]
-------------
@Path("widgets")
@Produces("application/widgets+xml")
public class WidgetsResource {

    @GET
    public Widgets getAsXML() {...}

    @GET
    @Produces("text/html")
    public String getAsHtml() {...}

    @POST
    @Consumes("application/widgets+xml")
    public void addWidget(Widget widget) {...}
}

@Provider
@Produces("application/widgets+xml")
public class WidgetsProvider implements MessageBodyWriter<Widgets> {...}

@Provider
@Consumes("application/widgets+xml")
public class WidgetProvider implements MessageBodyReader<Widget> {...}
-------------

In the above:

* The `getAsXML` resource method will be called for `GET` requests that
specify a response media type of `application/widgets+xml`. It returns a
`Widgets` instance that will be mapped to that format using the
`WidgetsProvider` class (see <<entity_providers>> for more
information on `MessageBodyWriter`).
* The `getAsHtml` resource method will be called for `GET` requests that
specify a response media type of `text/html`. It returns a `String`
containing `text/html` that will be written using the default
implementation of `MessageBodyWriter<String>`.
* The `addWidget` resource method will be called for `POST` requests
that contain an entity of the media type `application/widgets+xml`. The
value of the `widget` parameter will be mapped from the request entity
using the `WidgetProvider` class (see <<entity_providers>> for
more information on `MessageBodyReader`).

An implementation MUST NOT invoke a method whose effective value of
`@Produces` does not match the request `Accept` header. An
implementation MUST NOT invoke a method whose effective value of
`@Consumes` does not match the request `Content-Type` header.

When accepting multiple media types, clients may indicate preferences by
using a relative quality factor known as the q parameter. The value of
the q parameter, or q-value, is used to sort the set of accepted types.
For example, a client may indicate preference for
`application/widgets+xml` with a relative quality factor of 1 and for
`application/xml` with a relative quality factor of 0.8. Q-values range
from 0 (undesirable) to 1 (highly desirable), with 1 used as default
when omitted. A `GET` request matched to the `WidgetsResource` class
with an accept header of
`text/html; q=1, application/widgets+xml; q=0.8` will result in a call
to method `getAsHtml` instead of `getAsXML` based on the value of q.

A server can also indicate media type preference using the qs parameter;
server preference is only examined when multiple media types are
accepted by a client _with the same q-value_. Consider the following
example:

[source,java,numbered]
-------------
@Path("widgets2")
public class WidgetsResource2 {

    @GET
    @Produces("application/xml", "application/json")
    public Widgets getWidget() {...}

}
-------------

Suppose a client issues a `GET` request with an accept header of
`application/*; q=0.5, text/html`. Based on this request, the server
determines that both `application/xml` and `application/json` are
equally preferred by the client with a q-value of 0.5. By specifying a
server relative quality factor as part of the `@Produces` annotation, it
is possible to control which response media type to select:

[source,java,numbered]
-------------
@Path("widgets2")
public class WidgetsResource2 {

    @GET
    @Produces("application/xml; qs=1", "application/json; qs=0.75")
    public Widgets getWidget() {...}

}
-------------

With the updated value for `@Produces` in this example, and in response
to a `GET` request with an accept header that includes
`application/*; q=0.5`, JAX-RS implementations are REQUIRED to select
the media type `application/xml` given its higher qs-value. Note that
qs-values, just like q-values, are relative and as such are only
comparable to other qs-values within the same `@Produces` annotation
instance. For more information see <<determine_response_type>>.

[[annotationinheritance]]
=== Annotation Inheritance

JAX-RS annotations may be used on the methods and method parameters of a
super-class or an implemented interface. Such annotations are inherited
by a corresponding sub-class or implementation class method provided
that the method and its parameters do not have any JAX-RS annotations of
their own. Annotations on a super-class take precedence over those on an
implemented interface. The precedence over conflicting annotations
defined in multiple implemented interfaces is implementation specific.
Note that inheritance of class or interface annotations is not
supported.

If a subclass or implementation method has any JAX-RS annotations then
_all_ of the annotations on the superclass or interface method are
ignored. E.g.:

[source,java,numbered]
-------------
public interface ReadOnlyAtomFeed {
    @GET @Produces("application/atom+xml")
    Feed getFeed();
}

@Path("feed")
public class ActivityLog implements ReadOnlyAtomFeed {
    public Feed getFeed() {...}
}
-------------

In the above, `ActivityLog.getFeed` inherits the `@GET` and
`@Produces` annotations from the interface. Conversely:

[source,java,numbered]
-------------
@Path("feed")
public class ActivityLog implements ReadOnlyAtomFeed {
    @Produces("application/atom+xml")
    public Feed getFeed() {...}
}
-------------

In the above, the `@GET` annotation on `ReadOnlyAtomFeed.getFeed` is not
inherited by `Activity-Log.getFeed` and it would require its own request
method designator since it redefines the `@Produces` annotation.

For consistency with other Java EE specifications, it is recommended to
always repeat annotations instead of relying on annotation inheritance.

[[mapping_requests_to_java_methods]]
=== Matching Requests to Resource Methods

This section describes how a request is matched to a resource class and
method. Implementations are not required to use the algorithm as written
but MUST produce results equivalent to those produced by the algorithm.

[[reqpreproc]]
==== Request Preprocessing

Prior to matching, request URIs are normalizedfootnote:[Note: some
containers might perform this functionality prior to passing the request
to an implementation.] by following the rules for case, path segment,
and percent encoding normalization described in section 6.2.2 of RFC
3986<<bib5>>. The normalized request
URI MUST be reflected in the URIs obtained from an injected `UriInfo`.

[[request_matching]]
==== Request Matching

A request is matched to the corresponding resource method or
sub-resource method by comparing the normalized request URI (see
<<reqpreproc>>), the media type of any request entity, and the requested
response entity format to the metadata annotations on the resource
classes and their methods. If no matching resource method or
sub-resource method can be found then an appropriate error response is
returned. All exceptions reported by this algorithm MUST be processed as
described in <<method_exc>>.

Matching of requests to resource methods proceeds in three stages as
follows:

1.  Identify a set of candidate root resource classes matching the
request:
+
Input::
  latexmath:[$U=\mbox{request URI path},C=\{\mbox{root resource classes}\}$]
Output::
  latexmath:[$U=\mbox{final capturing group not yet matched}, C'=\{\mbox{root resouce classes matched so far}\}$]
    a.  Set latexmath:[$E=\{\}$].
    b.  For each class latexmath:[$Z$] in latexmath:[$C$] add a regular
expression (computed using the function latexmath:[$R(A)$] described in
<<template_to_regex>>) to latexmath:[$E$] as follows:
* Add latexmath:[$R(T_Z)$] where latexmath:[$T_Z$] is the URI
path template specified for the class latexmath:[$Z$].
+
Note that two or more classes in latexmath:[$C$] may add the same
regular expression to latexmath:[$E$] if they are annotated with the
same URI path template (modulo variable names).
    c.  Filter latexmath:[$E$] by matching each member against
latexmath:[$U$] as follows:
* Remove members that do not match latexmath:[$U$].
* Remove members for which the final regular expression capturing group
(henceforth simply referred to as a capturing group) value is neither
empty nor / and the class latexmath:[$Z$] has no sub-resource methods or
locators.
    d.  If latexmath:[$E$] is empty then no matching resource can be found,
the algorithm terminates and an implementation MUST generate a
`NotFoundException` (404 status) and no entity.
    e.  Sort latexmath:[$E$] using the number of literal
charactersfootnote:[Here, literal characters means those not resulting
from template variable substitution.] in each member as the primary key
(descending order), the number of capturing groups as a secondary key
(descending order) and the number of capturing groups with non-default
regular expressions (i.e. not ([ /]+?)) as the tertiary key (descending
order).
    f.  Set latexmath:[$R_{\mbox{match}}$] to be the first member of
latexmath:[$E$] and set latexmath:[$U$] to be the value of the final
capturing group of latexmath:[$R_{\mbox{match}}$] when matched against
latexmath:[$U$]. Let latexmath:[$C'$] be the set of classes
latexmath:[$Z$] such that latexmath:[$R(T_Z)=R_{\mbox{match}}$]. By
definition, all root resource classes in latexmath:[$C'$] must be
annotated with the same URI path template modulo variable names.
2.  Obtain a set of candidate resource methods for the
request:
+
Input::
  latexmath:[$U=\mbox{final capturing group not yet matched}, C'=\{\mbox{root resouce classes matched so far}\}$]
Output::
  latexmath:[$M=\{\mbox{candidate resource methods}$]}
    a.  [check_null] If latexmath:[$U$] is null or /, set
latexmath:[\[M = \{\mbox{resource methods of all classes in $C'$ (excluding sub-resource methods)}\}\]]
and go to step [find_method] if latexmath:[$M \neq \{\}$]
    b.  Set latexmath:[$E=\{\}$].
    c.  For each class latexmath:[$Z'$] in latexmath:[$C'$] add regular
expressions to latexmath:[$E$] for each sub-resource method and locator
as follows:
        i) For each sub-resource method latexmath:[$D$], add
latexmath:[$R(T_D)$] where latexmath:[$T_D$] is the URI path template of
the sub-resource method.
        ii) For each sub-resource locator latexmath:[$L$], add
latexmath:[$R(T_L)$] where latexmath:[$T_L$] is the URI path template of
the sub-resource locator.
    d.  Filter latexmath:[$E$] by matching each member against
latexmath:[$U$] as follows:
* Remove members that do not match latexmath:[$U$].
* Remove members derived from latexmath:[$T_D$] (those added in step
[t_method_items]) for which the final capturing group value is neither
empty nor /.
    e.  If latexmath:[$E$] is empty, then no matching resource can be found
and the algorithm terminates by generating a `NotFoundException` (404
status) and no entity.
    f.  Sort latexmath:[$E$] using the number of literal characters in each
member as the primary key (descending order), the number of capturing
groups as a secondary key (descending order), the number of capturing
groups with non-default regular expressions (i.e. not ([ /]+?)) as the
tertiary key (descending order), and the source of each member as
quaternary key sorting those derived from sub-resource methods ahead of
those derived from sub-resource locators.
    g.  Set latexmath:[$R_{\mbox{match}}$] to be the first member of
latexmath:[$E$]
    h.  Set latexmath:[$M$] as follows,
latexmath:[M = \{\mbox{subresource methods of all classes in $C'$ (excluding sub-resource locators)}\}\]]
and go to step 3 if latexmath:[$M \neq \{\}$].
    i.  Let latexmath:[$L$] be a sub-resource locator such that
latexmath:[$R_{\mbox{match}} = R(T_L)$]. Implementations SHOULD report
an error if there is more than one sub-resource locator that satisfies
this condition. Set latexmath:[$U$] to be the value of the final
capturing group of latexmath:[$R(T_L)$] when matched against
latexmath:[$U$], and set latexmath:[$C'$] to be the singleton set
containing only the class that defines latexmath:[$L$].
    j. Go to step 2a.
3.  Identify the method that will handle the request:
+
Input::
  latexmath:[$M=\mbox{candidate resource methods}$]
Output::
  latexmath:[$O=\mbox{instance of resource class matched}, D=\mbox{resource method matched from $M$}$]
    a.  Filter latexmath:[$M$] by removing members that do
not meet the following criteria:
* The request method is supported. If no methods support the request
method an implementation MUST generate a `NotAllowedException` (405
status) and no entity. Note the additional support for `HEAD` and
`OPTIONS` described in Section [head_and_options].
* The media type of the request entity body (if any) is a supported
input data format (see Section [declaring_method_capabilities]). If no
methods support the media type of the request entity body an
implementation MUST generate a `NotSupportedException` (415 status) and
no entity.
* At least one of the acceptable response entity body media types is a
supported output data format (see Section
[declaring_method_capabilities]). If no methods support one of the
acceptable response entity body media types an implementation MUST
generate a `NotAcceptableException` (406 status) and no entity.
    b.  If after filtering the set latexmath:[$M$] has more than one
element, sort it in descending order as follows. First, let us define
the _client_ media type and the _server_ media type as those denoted by
the `Accept` header in a request and the `@Produces` annotation on a
resource method, respectively. Let a client media type be of the form
latexmath:[$\mbox{$n$/$m$;q=$v_1$}$], a server media type be of the form
latexmath:[$\mbox{$n$/$m$;qs=$v_2$}$] and a _combined_ media type of the
form latexmath:[$\mbox{$n$/$m$;q=$v_1$;qs=$v_2$;d=$v_3$}$], where the
distance factor latexmath:[$d$] is defined below. For any of these
types, latexmath:[$m$] could be latexmath:[$*$], or latexmath:[$m$] and
latexmath:[$n$] could be latexmath:[$*$] and the values of q and qs are
assumed to be latexmath:[$1.0$] if absent.
+
Let latexmath:[$S(p_1, p_2)$] be defined over a client media type
latexmath:[$p_1$] and a server media type latexmath:[$p_2$] as the
function that returns the _most_ specific combined type with a distance
factor if latexmath:[$p_1$] and latexmath:[$p_2$] are compatible and
latexmath:[${\perp}$] otherwise. For example:
* latexmath:[$S(\mbox{text/html;q=1}, \mbox{text/html;qs=1}) = \mbox{text/html;q=1;qs=1;d=0}$],
* latexmath:[$S(\mbox{text/*;q=0.5}, \mbox{text/html;qs=0.8}) = \mbox{text/html;q=0.5;qs=0.8;d=1}$],
* latexmath:[$S(\mbox{*/*;q=0.2}, \mbox{text/*;qs=0.9}) = \mbox{text/*;q=0.2;qs=0.9;d=1}$],
* latexmath:[$S(\mbox{text/*;q=0.4}, \mbox{application/*;qs=0.3}) = {\perp}$].
+
where the latexmath:[$d$] factor corresponds to the number of wildcards
matched with a concrete type or subtype. Note that q and qs are not
matched, but simply combined in the resulting media type. A total
ordering can be defined over combined media types as follows.
+
We write
latexmath:[$\mbox{$n_1$/$m_1$;q=$v_1$;qs=$v_1'$;d=$v_1''$} \ge \mbox{$n_2$/$m_2$;q=$v_2$;qs=$v_2'$;d=$v_2''$}$]
if one of these ordered conditions holds:
i)  latexmath:[$\mbox{$n_1$/$m_1$} \succ \mbox{$n_2$/$m_2$}$] where the
partial order latexmath:[$\succ$] is defined as
latexmath:[$\mbox{$n$/$m$} \succ \mbox{$n$/*} \succ \mbox{*/*}$],
ii)  latexmath:[$\mbox{$n_2$/$m_2$} \nsucc \mbox{$n_1$/$m_1$}$] and
latexmath:[$v_1 > v_2$],
iii)  latexmath:[$\mbox{$n_2$/$m_2$} \nsucc \mbox{$n_1$/$m_1$}$] and
latexmath:[$v_1 = v_2$] and latexmath:[$v_1' > v_2'$].
iv)  latexmath:[$\mbox{$n_2$/$m_2$} \nsucc \mbox{$n_1$/$m_1$}$] and
latexmath:[$v_1 = v_2$] and latexmath:[$v_1' = v_2'$] and
latexmath:[$v_1'' \le v_2''$].
+
Note that latexmath:[$\ge$] is a total order even though
latexmath:[$\succ$] is a partial order. For example, the following holds
latexmath:[$\mbox{text/html;q=1.0;qs=0.7;d=0} \ge \mbox{application/xml;q=1.0;qs=0.2;d=0}$]
even though latexmath:[$\mbox{text/html}$] is incomparable to
latexmath:[$\mbox{application/xml}$] according to latexmath:[$\succ$].
Additionally, it is possible under latexmath:[$\ge$] for two types to be
equal even though they are not identical footnote:[E.g.,
latexmath:[$\mbox{text/html;q=1.0;qs=0.7;d=0} \ge \mbox{application/xml;q=1.0;qs=0.7;d=0}$]
and
latexmath:[$\mbox{application/xml;q=1.0;qs=0.7;d=0} \ge \mbox{text/html;q=1.0;qs=0.7;d=0}$].].
For convenience, we defined latexmath:[$p \ge {\perp}$] for every media
type latexmath:[$p$].
+
Given these definitions, we can now sort latexmath:[$M$] in descending
order based on latexmath:[$\ge$] as followsfootnote:[If any of these
types or sets of types are unspecified, latexmath:[$\mbox{*/*}$] and
latexmath:[$\mbox{\{*/*\}}$] are assumed.]:
* Let latexmath:[$t$] be the request content type and latexmath:[$C_M$]
a resource method’s `@Consumes` set of server media types, we use the
media type
latexmath:[$\max_\ge \{ S(t,c)  \, | \, (t, c) \in \{t\} \times C_M\}$]
as primary key.
* Let latexmath:[$A$] be the request accept header set of client media
types and latexmath:[$P_M$] a resource method’s `@Produces` set of
server media types, we use the media type
latexmath:[$\max_\ge \{ S(a,p) \, | \, (a,p) \in A \times P_M\}$] as
secondary key. If there is more than one maximum element ,
implementations SHOULD report a warning and select one of these types in
an implementation dependent manner.
c.  Let latexmath:[$D$] be the first resource method
in the set latexmath:[$M$]footnote:[Step [filter_methods] ensures the
set contains at least one member.] and latexmath:[$O$] an instance of
the class that defines latexmath:[$D$]. If after sorting, there is more
than one maximum element in latexmath:[$M$], implementations SHOULD
report a warning and select one of these methods in an implementation
dependent manner.
+
Consider the following example and assume the request to be `GET`
`widgets/1`:
+
[source,java,numbered]
-------------
@Path("widget")
public class WidgetResource {
    private String id;

    public WidgetResource() {
        this("0");
    }

    public WidgetResource(String id) {
        this.id = id;
    }

    @GET
    public Widget findWidget() {
        return Widget.findWidgetById(id);
    }
}

@Path("widgets")
public class WidgetsResource {

    @Path("{id}")
    public WidgetResource getWidget(@PathParam("id") String id) {
        return new WidgetResource(id);
    }
}
-------------
+
The input and output values for each of the 3 steps in the matching
algorithm are as follows:
+
Step 1::
  Identify a set of candidate root resource classes matching the
  request. Let latexmath:[$R(\mbox{widgets}) = \mbox{widgets(/.*)?}$]
  and latexmath:[$R(\mbox{widget}) = \mbox{widget(/.*)?}$],
  +
  Input;;
    latexmath:[$U = \mbox{widgets/1}$] and
    latexmath:[$C = \{\mbox{WidgetResource}, \mbox{WidgetsResource}\}$]
  Output;;
    latexmath:[$U = \mbox{/1}$] and
    latexmath:[$C' = \{\mbox{WidgetsResource}\}$]
Step 2::
  Obtain a set of candidate resource methods for the request. Let
  latexmath:[$R(\{\mbox{id}\}) = \mbox{([\^{ }/]+?)(/.*)?}$],
  +
  Input;;
    latexmath:[$U = \mbox{/1}$] and
    latexmath:[$C' = \{\mbox{WidgetsResource}\}$]
  Output;;
    latexmath:[$M = \{\mbox{findWidget}\}$]
Step 3::
  Identify the method that will handle the request,
  +
  Input;;
    latexmath:[$M = \{\mbox{findWidget}\}$]
  Output;;
    latexmath:[$O = \mbox{WidgetResource instance}$] and
    latexmath:[$D = \mbox{findWidget}$]
+
Note that the algorithm matches a single root resource class
(WidgetsResource) and, consequently, the `@Path` annotation on
WidgetResource is ignored for the request `GET` `widgets/1`.

[[template_to_regex]]
==== Converting URI Templates to Regular Expressions

The function latexmath:[$R(A)$] converts a URI path template annotation
latexmath:[$A$] into a regular expression as follows:

1.  URI encode the template, ignoring URI template variable
specifications.
2.  Escape any regular expression characters in the URI template, again
ignoring URI template variable specifications.
3.  Replace each URI template variable with a capturing group containing
the specified regular expression or ([ /]+?) if no regular expression is
specifiedfootnote:[Note that the syntax +? denotes a reluctant
quantifier as defined in the java.util.regex.Pattern class.].
4.  If the resulting string ends with / then remove the final character.
5.  Append (/.*)? to the result.

Note that the above renders the name of template variables irrelevant
for template matching purposes. However, implementations will need to
retain template variable names in order to facilitate the extraction of
template variable values via `@PathParam` or
`UriInfo``.getPathParameters`.

[[determine_response_type]]
=== Determining the MediaType of Responses

In many cases it is not possible to statically determine the media type
of a response. The following algorithm is used to determine the response
media type, latexmath:[$M_{\mbox{selected}}$], at run time:

1.  If the method returns an instance of `Response` whose metadata
includes the response media type (latexmath:[$M_{\mbox{specified}}$])
then set latexmath:[$M_{\mbox{selected}} = M_{\mbox{specified}}$],
finish.
2.  Gather the set of producible media types latexmath:[$P$]:
* If the method is annotated with `@Produces`, set
latexmath:[$P = \{ V(\mbox{method}) \}$] where latexmath:[$V(t)$]
represents the values of `@Produces` on the specified target
latexmath:[$t$].
* Else if the class is annotated with `@Produces`, set
latexmath:[$P = \{ V(\mbox{class}) \}$].
* Else set latexmath:[$P = \{ V(\mbox{writers}) \}$] where writers is
the set of `MessageBodyWriter` that support the class of the returned
entity object.
3.  If latexmath:[$P = \{\}$], set
latexmath:[$P = \{\mbox{\lq*/*\rq}\}$]
4.  Obtain the acceptable media types latexmath:[$A$]. If
latexmath:[$A = \{\}$], set latexmath:[$A = \{\mbox{\lq*/*\rq}\}$]
5.  Set latexmath:[$M=\{\}$]. For each member of latexmath:[$A, a$]:
* For each member of latexmath:[$P, p$]:
** If latexmath:[$a$] is compatible with latexmath:[$p$], add
latexmath:[$S(a,p)$] to latexmath:[$M$], where the function
latexmath:[$S$] returns the most specific media type of the pair with
the q-value of latexmath:[$a$] and server-side qs-value of
latexmath:[$p$].
6.  If latexmath:[$M = \{\}$] then generate a `NotAcceptableException`
(406 status) and no entity. The exception MUST be processed as described
in <<method_exc>>. Finish.
7.  Sort latexmath:[$M$] in descending order, with a primary key of
specificity (latexmath:[$\mbox{n/m} > \mbox{n/*} > \mbox{*/*}$]), a
secondary key of q-value and a tertiary key of qs-value.
8.  For each member of latexmath:[$M, m$]:
* If latexmath:[$m$] is a concrete type, set
latexmath:[$M_{\mbox{selected}} = m$], finish.
9.  If latexmath:[$M$] contains /* or application/*, set
latexmath:[$M_{\mbox{selected}} = \mbox{\lq application/octet-stream\rq}$],
finish.
10. Generate a `NotAcceptableException` (406 status) and no entity. The
exception MUST be processed as described in <<method_exc>>.
Finish.

Note that the above renders a response with a default media type of
application/octet-stream when a concrete type cannot be determined. It
is RECOMMENDED that `MessageBodyWriter` implementations specify at least
one concrete type via `@Produces`.
